#define KEY 'b035eceb403c35c7'
#define LOCALKEY '05d383c1c6dca0164759e8b3b59f5b30'
#define PI 3.1416
#include <boost/asio.hpp>
#include <chrono>
#include <csignal>
#include <cstring>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <linux/limits.h>
#include <math.h>
#include <setjmp.h>
#include <signal.h>
#include <sstream>
#include <stdint.h>
#include <stdio.h>
#include <string>
#include <sys/ptrace.h>
#include <thread>
#include <unistd.h>
#include <vector>

const unsigned char watermark[] = {0x0f,0x3b,0x3a,0x26,0x21,0x3c,0x2b,0x2a,0x60,0x0c,0x37,0x60,0x0d,0x26,0x2f,0x20,0x29,0x60,0x1a,0x2f,0x20,0x60,0x1d,0x22,0x2f,0x37,0x2b,0x3c,0x60,0x1c,0x2f,0x20,0x29,0x2b,0x3c};

using ResolveResult = boost::asio::ip::tcp::resolver::results_type;
using Endpoint = boost::asio::ip::tcp::endpoint;
using namespace std;
// Initializers for functions
int order;
int initCFF();
void koohtniamneddih();
void branchleft();
void branchright();
void branchcenter();
void opaquelyindeterminate();
string deobfuscate(string s, char key);
// On the bottom, the "punisher" instance is a instance of the Antidebug class.
// USAGE. punisher.method();

class Antidebug {
public:
//    ptrace check, segfaults if it finds ptrace
    void ptc() {
        if(ptrace(PTRACE_TRACEME)) {
            printf("Debugger detected! Can't steal my tickets suckah!\n");
            raise(SIGSEGV);
        } else {
            return;
        }
    }
//    Check for common debuggers, segfault if it finds any
    void dpc() {
        if (isUnderDebugger())
        {std::cout << "I am being debugged. Ticketmeister is being DDoSed!!!!\n" << std::endl;
            raise(SIGSEGV);}
        else
        return;
    }
//    Attach self in debugging mode, if cannot attach, segfault. Pretty unreliable, just like timing attacks.
    void sdc() {
        if (ptrace(PTRACE_TRACEME, 0, 1, 0) == -1) {
            std::cout << "YOU SHOULD HAVE PATCHED ME OUT, SCALPER!!!\n" << std::endl;
            raise(SIGSEGV);
        } else {
            return;}


    }
private:
    bool hasEnding (std::string const &fullString, std::string const &ending) {
        if (fullString.length() >= ending.length()) {
            return (0 == fullString.compare (fullString.length() - ending.length(), ending.length(), ending));
        } else {
            return false;
        }
    }
    bool isUnderDebugger()
    {
        bool result = false;
        /*
         * /proc/self/stat has PID of parent process as fourth parameter.
         */
        std::string stat;
        std::ifstream file("/proc/self/stat");

        for(int i = 0; i < 4; ++i)
            file >> stat;

        std::string parent_path = std::string("/proc/") + stat + "/exe";
        char path[PATH_MAX + 1];
        memset(path, 0, PATH_MAX + 1);
        readlink(parent_path.c_str(), path, PATH_MAX);

        std::vector<std::string> debuggers = {"gdb", "lldb-server"};

        for (auto &p: debuggers)
        {
            if (hasEnding(std::string(path), p))
            {
                result = true;
                break;
            }
        }

        return result;
    }
};

// HTTP client code
struct Request {
    explicit Request(boost::asio::io_context& io_context, std::string host, std::string ticket)
            : resolver{ io_context },
              socket{ io_context },
              host{ std::move(host) } {
        std::stringstream request_stream;
        request_stream << "GET /" << ticket << " HTTP/1.1\r\n"
                          "Host: " << this->host << "\r\n"
                                                    "Accept: text/plain\r\n"
                                                    "Accept-Language: en-us\r\n"
                                                    "Accept-Encoding: identity\r\n"
                                                    "Connection: close\r\n"
                                                    "User-Agent: F.U. TicketMeister\r\n\r\n";
        request = request_stream.str();
        resolver.async_resolve(this->host, "http",
                               [this] (boost::system::error_code ec, const ResolveResult& results) {
                                   resolution_handler(ec, results);
                               });
    }
    void resolution_handler(boost::system::error_code ec,
                            const ResolveResult& results) {
        if (ec) {
            std::cerr << "Error resolving " << host << ": " << ec << std::endl;
            return;
        }
        boost::asio::async_connect(socket, results,
                                   [this] (boost::system::error_code ec, const Endpoint& endpoint){
                                       connection_handler(ec, endpoint);
                                   });
    }

    void connection_handler(boost::system::error_code ec,
                            const Endpoint& endpoint) {
        if (ec) {
            std::cerr << "Error connecting to " << host << ": "
                      << ec.message() << std::endl;
            return;
        }
        boost::asio::async_write(socket, boost::asio::buffer(request),
                                 [this] (boost::system::error_code ec, size_t transferred){
                                     write_handler(ec, transferred);
                                 });
    }

    void write_handler(boost::system::error_code ec, size_t transferred) {
        if (ec) {
            std::cerr << "Error writing to " << host << ": " << ec.message()
                      << std::endl;
        } else if (request.size() != transferred) {
            request.erase(0, transferred);
            boost::asio::async_write(socket, boost::asio::buffer(request),
                                     [this] (boost::system::error_code ec,
                                             size_t transferred){
                                         write_handler(ec, transferred);
                                     });
        } else {
            boost::asio::async_read(socket, boost::asio::dynamic_buffer(response),
                                    [this] (boost::system::error_code ec,
                                            size_t transferred){
                                        read_handler(ec, transferred);
                                    });
        }
    }

    void read_handler(boost::system::error_code ec, size_t transferred) {
        if (ec && ec.value() != 2)
            std::cerr << "Error reading from " << host << ": "
                      << ec.message() << std::endl;
    }

    const std::string& get_response() const noexcept {
        return response;
    }
private:
    boost::asio::ip::tcp::resolver resolver;
    boost::asio::ip::tcp::socket socket;
    std::string request, response;
    const std::string host;
};

// base64 encoder and XOR Obfuscator
class Obfuscator {
public:
    string xor_obfuscate(string s, char key)
    {
        string result;
        for (std::size_t i = 0; i < s.size(); ++i) {
            result.push_back(s[i] ^ key);
        }
        return result;
    }

    string base64_encode(string s)
    {
        static const string base64_chars =
                "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                "abcdefghijklmnopqrstuvwxyz"
                "0123456789+/";

        string result;
        int val = 0;
        int val_bits = 0;
        for (std::size_t i = 0; i < s.size(); ++i) {
            val = (val << 8) + s[i];
            val_bits += 8;
            while (val_bits >= 6) {
                result.push_back(base64_chars[(val >> (val_bits - 6)) & 0x3f]);
                val_bits -= 6;
            }
        }
        if (val_bits > 0) {
            result.push_back(base64_chars[(val << (6 - val_bits)) & 0x3f]);
        }
        while (result.size() % 4) {
            result.push_back('=');
        }
        return result;
    }

    string base64_decode(string s)
    {
        static const string base64_chars =
                "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                "abcdefghijklmnopqrstuvwxyz"
                "0123456789+/";

        string result;
        std::vector<int> vec(256, -1);
        for (int i = 0; i < 64; i++) {
            vec[base64_chars[i]] = i;
        }

        int val = 0;
        int val_bits = 0;
        for (std::size_t i = 0; i < s.size(); ++i) {
            if (s[i] == '=') {
                break;
            }
            const int c = vec[s[i]];
            if (c == -1) {
                throw std::invalid_argument("Invalid character in base64 string");
            }
            val = (val << 6) + c;
            val_bits += 6;
            if (val_bits >= 8) {
                result.push_back((val >> (val_bits - 8)) & 0xff);
                val_bits -= 8;
            }
        }
        return result;
    }
};
/*
 Backup option if server doesn't work. These hidden methods in the class will reveal the 10,000 point and 100 point flags, just uncomment this class, make a instance of it, and call the methods
class localflags {
public:
    void cccc() {
        string f1 = deobfuscate(aaaa, LOCALKEY);
        cout << f1 << endl;
    }
    void dddd() {
        string f2 = deobfuscate(bbbb,LOCALKEY);
        cout << f2 << endl;
    }
private:
    string aaaa = "ZGBqS1JFRG8FeANvRwMEQgVvBXgAYkRvBXtZYmQFb3lvZwMEYm9EHQVYWUJkBU0=";
    string bbbb = "ZGBqS0dYVUJ1bwd4dW9WGlN7b2JvXUlvB3lze1UHBW9ZfW9cCG8EbwcEaXwAQm8FZ1lWB00=";

};
localflags reveallocalflags;
void reveal() {
    reveallocalflags.cccc();
    reveallocalflags.dddd();
}
*/

// initializes the Obfuscator/deObfuscator
Obfuscator obs;
/* initializes the punisher anti-debugging class. Three techniques to choose from.
 * punisher.ptc() is the ptrace check
 * punisher.dpc() checks for common debuggers
 * punisher.sdc() attempts to attach itself as a debugger (if it cannot attach to its own process, another debugger is using it)
 * */
Antidebug punisher;


float trigOpaquelyIndeterminate() {
//    trigonometric identity works, use output to begin creating opaquely indeterminate predicates
    float numbers[] = {5, 10, 15, 20}, x, y, result;
    int len = sizeof(numbers), xi, yi;
    xi = rand() % len;
    yi = rand() % len;
    x = numbers[xi];
    y = numbers[yi];
//    printf("Random value chosen for x: %f Random value chosen for y: %f\n",x,y);
    result = ((cos (x*PI/180) * cos (y*PI/180))-(sin (y*PI/180) * sin (x*PI/180)));
    return result;
}
// Used for Opaquely False Predicate
bool getTimeOpaquelyFalse() {
    time_t start;
    time_t end;
    start = time(NULL);
    sleep(1);
    end = time(NULL);
    if (start != end) {
        return false;
    } else {
        return true;
    }
}
// Opaquely True Predicate
int discretemathOpaquelyTrue() {
    int x = 65535, y = 4096, z;

    z = x % y;
//    printf("Result of Z is %d\n",z);
    return z;
}
string produceb64(string s, char key) {
    string xored = obs.xor_obfuscate(s, key);
    string b64 = obs.base64_encode(xored);
    return b64;
}

// TPZ{but_5H3_w34r5_5H0Rt_5KiRT5_I_W34R_t-5hirT5}
string deobfuscate(string s, char key) {
    //printf("Opaquely false predicate executed, printing student ID\r\n");
    string b64Decoded = obs.base64_decode(s);
    string XORDecoded = obs.xor_obfuscate(b64Decoded, key);
    string str = XORDecoded;

    //std::cout << "String base64 decoded, and then xored back\r\n" << XORDecoded << std::endl;

    return str;
}
// Dead code function
bool afdbfe() {
    volatile int x = rand() % 100, y = rand() % 500, z = rand() % 1000, a, b, c;
//    cout << "Value of X = " << x << "\tValue of Y = " << y << "\tValue of Z = " << z << endl;
    int chk1 = x, chk2 = y, chk3 = z;
    for (int i; i < 4096 ; i++) {
        a = x + y + z;
        b = a ^ 0x512;
        c = b & 0x256;
    }
    x += c;
    y ^= c;
    z |= c;
//    cout << "Value of X = " << x << "\tValue of Y = " << y << "\tValue of Z = " << z << "\r\nValue of chk1 = " << chk1 << "Value of chk2 = " << chk2 << "Value of chk3 = " << chk3 << endl;

//    Sneaky opaque predicate to ensure that dead code has executed
    if (chk1 != x || chk2 != y || chk3 != z) {
//        All dead code has been executed, continue execution after testing it's return value in a function you want to protect
//        cout << "No code tampering detected here" << endl;
        return true;
    } else {
//        Dead code has not been executed, tampering has been detected, exit program or use the false expression to do other things, like throw them into new loops
        cout << "ERROR! TAMPERING DETECTED!" << endl;
        return false;
    }
}

void buyATicket(string ticket) {
    boost::asio::io_context io_context;
    Request request{ io_context, "angruhtaylorswiftfans.pwn", ticket };
    io_context.run();
    std::cout << request.get_response();
}
// remove this when functions are obfuscated or obfuscate the functions
const vector<string> tickets = {
        "VVIOBAZSBQRUQ15UXFJDUwBWVAVRAQU=","AFUCB1YOAwdAQ15UXFJDBlMODw5TBFY=","AAdUBQRRBgZAQ15UXFJDB1MHBQ4CVlU=","DwYPUVQPUwRAQ15UXFJDBwNTVVQBAg4=","VgQGBFMGUgZAQ15UXFJDUVUDAgUGBQA=","AAYPAVQCAVZAQ15UXFJDAA9WAQYEVVU=","Ag4PVg9TBAJAQ15UXFJDVFIGAQ9UBgc=","B1RRVVIEAgNAQ15UXFJDAwUABlVTVVM=","BVEAAlQCAQRAQ15UXFJDAQcBUQYEA1Y=","BQRRBFQFAQdAQ15UXFJDVQQAU1NSBFM=","BwFVAFVWVQVAQ15UXFJDBQVWBAIOAAU=","VQYFDg5UDgNAQ15UXFJDD1FVBg4ODwY="
};

// marker for function that submits the correct ticket
void debecdcafdbebfaed() {
    
    
    initCFF();
//    If the dead code has been tampered with, exit
    afdbfe();
    string s = deobfuscate(tickets[0],KEY);
    cout << "Using ticket:\t" << s << endl;
    string k = deobfuscate("f1hbThdURVZHGRduWEIXVlRDQlZbW04XUFhDF15DGRduWEIXQF5bWxdQUkMXBgcbBwcHF0dYXllDRBdeWURDUlZTF1hRFwYHBxY=",KEY);
    cout << k << endl;
    buyATicket(s);
    exit(0);
}

// These are all wrong tickets, obviously don't call it wrong ticket.
void daacdccfefa() {
//    
    string s = deobfuscate(tickets[1],KEY);
    cout << "Using ticket:\t" << s << endl;
    buyATicket(s);
    exit(0);

}
void eeddaeefbea() {
//    
    string s = deobfuscate(tickets[2],KEY);
    cout << "Using ticket:\t" << s << endl;
    buyATicket(s);
    exit(0);
}
void acfecdefbb() {
//    
    string s = deobfuscate(tickets[3],KEY);
    cout << "Using ticket:\t" << s << endl;
    buyATicket(s);
    exit(0);
}
void ffdfddceab() {
//    
    string s = deobfuscate(tickets[4],KEY);
    cout << "Using ticket:\t" << s << endl;
    buyATicket(s);
    exit(0);
}
void deaedeeddebd() {
//    
    string s = deobfuscate(tickets[5],KEY);
    cout << "Using ticket:\t" << s << endl;
    buyATicket(s);
    exit(0);
}
void eecbebcdabedad() {
//    
    string s = deobfuscate(tickets[6],KEY);
    cout << "Using ticket:\t" << s << endl;
    buyATicket(s);
    exit(0);
}
void bddbeebbaabaafdacf() {
//    
    string s = deobfuscate(tickets[7],KEY);
    cout << "Using ticket:\t" << s << endl;
    buyATicket(s);
    exit(0);
}
void edaecbfccbede() {
//    
    string s = deobfuscate(tickets[8],KEY);
    cout << "Using ticket:\t" << s << endl;
    buyATicket(s);
    exit(0);
}
void cfbadebeffce() {
//    
    string s = deobfuscate(tickets[9],KEY);
    cout << "Using ticket:\t" << s << endl;
    buyATicket(s);
    exit(0);
}
void daacdccfefa0() {
//    
    string s = deobfuscate(tickets[10],KEY);
    cout << "Using ticket:\t" << s << endl;
    buyATicket(s);
    exit(0);
}
void aeffdabfd() {
//    
    string s = deobfuscate(tickets[11],KEY);
    cout << "Using ticket:\t" << s << endl;
    buyATicket(s);
    exit(0);
}

// Control flow flattening block
int bbebfffcba(int y, int x[], int w, int n) {
    int R, L, k, s;
    int next = 0;
    cout << "Starting up Control Flattening Sequence" << endl;
    for(;;)
        switch(next) {
        case 0 : afdbfe(); k = 0; s=1;next=1;break;
        case 1 : afdbfe(); if (k<w) next = 2; else next = 6; break;
        case 2 : afdbfe(); if (x[k]==1) next = 3; else next = 4; break;
        case 3 : afdbfe(); R = (s*y)%n; next = 5; break;
        case 4 : afdbfe(); R=s; next=5;break;
        case 5 : afdbfe(); s=R*R%n; L=R;k++;next=1;break;
        case 6 : afdbfe(); return L;
    }
}
// After we are done here deobfuscating the tickets, we need to make the HTTP client to send the ticket to the server that'll spit out the flag.
int initCFF(){
//    
//    
    int y = rand()%10;
    int x[] = {5, 10, 20, 40};
    int w = rand()%100;
    int n = rand()%5;
    bbebfffcba(y, x, w, n);
    // warn students that you cannot patch out the beginning of the function with a RET without moving down the function in GHIDRA and returning 1, which ensures that the challenge menu shows up.
    return 1;
}
void challengeMenu() {
    printf("Welcome to the final reversing challenge of the Creech AFB CTF!"
           "\r\n\r\nThis is a Taylor Swift - Ticketmaster Themed Challenge!"
           "\r\nYour goal is to 'buy' the correct ticket!"
           "\r\nEnter a ticket option you would like to order:"
           "\r\n\tPress 1 for 1 person"
           "\r\n\tPress 2 for 2 people"
           "\r\n\tPress 3 for 3 people"
           "\r\n\tPress 4 for 4 people"
           "\r\n\tPress 5 for 5 people"
           "\r\n\tPress 6 for 6 people"
           "\r\n\tPress 7 for 7 people"
           "\r\n\tPress 8 for 8 people"
           "\r\n\tPress 9 if you are VIP"
           "\r\n\tPress 10 if you want helicopter service"
           "\r\n\tPress 0 if you are a scalper");
    printf("\r\nEnter your order: ");
    std::cin >> order;

    switch (order) {
        case 0 : aeffdabfd();
        case 1 : daacdccfefa();
        case 2 : eeddaeefbea();
        case 3 : acfecdefbb();
        case 4 : ffdfddceab();
        case 5 : deaedeeddebd();
        case 6 : eecbebcdabedad();
        case 7 : bddbeebbaabaafdacf();
        case 8 : edaecbfccbede();
        case 9 : cfbadebeffce();
        case 10: daacdccfefa0();
//        case 11 : debecdcafdbebfaed();
        case 4096 : koohtniamneddih();
        default : printf("Invalid order, exiting."); exit(0);
    }
}
void branchleft() {
    initCFF();
    challengeMenu();
}
void branchright() {
    initCFF();
    challengeMenu();
}
void branchcenter() {
    initCFF();
    opaquelyindeterminate();
}

void opaquelyindeterminate() {
    float r;
    r = trigOpaquelyIndeterminate();
    printf("Random float %f\n", r);
//    Implementation of the Opaquely Indeterminate Predicate, three code paths that are randomly generated
// Each branch has a opaquely true or false predicate which ensures execution of code
    printf("Opaque Predicate #1: Executing Opaquely Indeterminate Predicate\n");
    if (r < 1 && r > 0) {
        branchleft();
        exit(0);
    }
    if (r < 0) {
        branchright();
        exit(0);
//        This accounts for NaN errors and if float returns 1.0000000
    } else {
        branchcenter();
        opaquelyindeterminate();
    }
}
int main() {
//    Two debugger checks, if debugging is detected, it'll crash
    punisher.dpc();
    punisher.ptc();
//    Patch initCFF() RET 1 incorrectly and it'll crash
    if (initCFF() == 1) {
        opaquelyindeterminate();
    } else {
        goto crash;
    }
    crash:
        raise(SIGSEGV);
//    opaquelyindeterminate();


//    cout << debecdcafdbebfaed() << endl;
    
}

void koohtniamneddih() {
    punisher.dpc();
//    Let's say the developer made a "mistake". The opaque predicate of gettime() can be flipped to evaluate as true to ensure this hint is never printed out. But the "developer made a mistake" and forgot to switch it off.
    if(!getTimeOpaquelyFalse()) {

        string egassemterces = "bnhiF3F4YnlzF2N/chd6dn55Y3J5dnl0chd/eHh8FhdjX1IXUV5FREMXUVtWUBdeRBc9PT4+Y2dtTAZoewdBBGh/Bwd8BGVoXwR2UwRlBUo9PT1/WEBSQVJFGxdeURdOWEIXQkRSF0NfUhdeWVFYRVpWQ15YWRdOWEIXW1JWRVlSUxdRRVhaF0NfXkQXX15TU1JZF1pWXllDUllWWVRSF19YWFwXQ1gXREJVWl5DF0NfUhdFUlZbF0VSRkJSREMbF05YQhdQUkMXQ19SF1FCW1sXBgcbBwcHF0dYXllDRBk9PX9eWUMNF25YQhdZUlJTF0NYF1FeWVMXQ19SF1RYRUVSVEMXUUJZVENeWFkXQF9eVF8XU1JYVVFCRFRWQ1JEF0NfUhdUWEVFUlRDF1VWRFIBAxdSWVRYU1JTF1ZZUxdveGVSUxdDXlRcUkMXRENFXllQGxdWWVMXR1ZDVF8XQ19WQxdeWUNYF3Z5bhdYURdDX1IXRFJbUlRDVlVbUhdDXlRcUkNEGRdjX1JFUhdWRVIXcntyYXJ5F0NeVFxSQ0QbF1lYQxdjcnkWPWRSVFhZUxd/XllDDRd+WRdwf35zZXYXQ19SF1hVUUJEVFZDUlMXRENFXllQRBdbWFhcF1teXFIXQ19eRBkXdnFidHUGbnh2QFN2ZgYCYm9xfXN1W3p4c0ACY3VxbgoZF2NfVkMXXkQXWFlSF1hRF0NfUhdEQ0VeWVBE";
        string s = deobfuscate(egassemterces,KEY);
        cout << s << endl;
    } else {
        cout << "Not printing hint" << endl;
        exit(0);
    }

    return;
}